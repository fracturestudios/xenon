
#include "keyboard.h"
#include "mouse.h"
#include "scheduler.h"
#include "window.h"

#include "xe/trace.h"

#include <QKeyEvent>
#include <QMouseEvent>

QtWindow::QtWindow(QWidget *parent) : QGLWidget(parent), m_sched(0), m_mouse(0), m_fullscreen(false), m_changingState(false)
{
    setMouseTracking(true);
    setCursor(Qt::BlankCursor);
    setFocusPolicy(Qt::StrongFocus);
    connect(&m_timer, SIGNAL(timeout()), this, SLOT(tick()));

    QGLFormat fmt = format();
    fmt.setDoubleBuffer(true);
    fmt.setSampleBuffers(true);
    fmt.setSwapInterval(1);
    setFormat(fmt);
}

QtWindow::~QtWindow() { }

QtScheduler *QtWindow::sched() const
{
    return m_sched;
}

void QtWindow::setSched(QtScheduler *sched)
{
    m_sched = sched;
}

QtMouse *QtWindow::mouse() const
{
    return m_mouse;
}

void QtWindow::setMouse(QtMouse *m)
{
    m_mouse = m;
}

QtKeyboard *QtWindow::keyboard() const
{
    return m_keyboard;
}

void QtWindow::setKeyboard(QtKeyboard *k)
{
    m_keyboard = k;
}

void QtWindow::initializeGL()
{
    // Set up tick timer (done here so we don't generate scheduler events
    // before the GL context is available)
    m_updateTime.start();
    m_renderTime.start();
    m_timer.start(10);

    QCursor::setPos(mapToGlobal(QPoint(width() / 2, height() / 2)));

    // Some reasonable OpenGL defaults
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_CULL_FACE);
    glEnable(GL_TEXTURE_2D);
}

void QtWindow::tick()
{
    xe_assert(sched(), "Native kernel init failure: no scheduler set");

    float dt = m_updateTime.restart() * 0.001f;
    sched()->onupdate(dt);

    update();  // flag widget for repainting
}

void QtWindow::paintGL()
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    if (!m_changingState)
    {
        xe_assert(sched(), "Native kernel init failure: no scheduler set");

        float dt = m_renderTime.restart() * 0.001f;
        sched()->onrender(dt);
    }
}

void QtWindow::resizeGL(int w, int h)
{
    glViewport(0, 0, w, h);
}

void QtWindow::mousePressEvent(QMouseEvent *ev)
{
    xe_assert(mouse(), "Native kernel init failure: no mouse set");
    mouse()->mousedown(ev);
}

void QtWindow::mouseReleaseEvent(QMouseEvent *ev)
{
    xe_assert(mouse(), "Native kernel init failure: no mouse set");
    mouse()->mouseup(ev);
}

void QtWindow::mouseMoveEvent(QMouseEvent *ev)
{
    int x0 = width() / 2, y0 = height() / 2;
    int dx = ev->x() - x0,
        dy = ev->y() - y0;

    // Calling QCursor::setPos() with dx == 0 && dy == 0 generates another 
    // mouseMoveEvent() and leads to infinite recursion fun
    if (dx || dy)
    {
        xe_assert(mouse(), "Native kernel init failure: no mouse set");
        mouse()->mousemove(dx, dy);
        QCursor::setPos(mapToGlobal(QPoint(x0, y0)));
    }
}

void QtWindow::wheelEvent(QWheelEvent *ev)
{
    xe_assert(mouse(), "Native kernel init failure: no mouse set");
    mouse()->mousescroll(ev);
}

void QtWindow::keyPressEvent(QKeyEvent *ev)
{
    xe_assert(keyboard(), "Native kernel init failure: no keyboard set");
    keyboard()->keydown(ev);
}

void QtWindow::keyReleaseEvent(QKeyEvent *ev)
{
    xe_assert(keyboard(), "Native kernel init failure: no keyboard set");
    keyboard()->keyup(ev);
}

void *QtWindow::handle() const
{
    return (void*)this;
}

const char *QtWindow::title() const
{
    return windowTitle().toUtf8().data();
}

void QtWindow::setTitle(const char *title)
{
    setWindowTitle(title);
}

XeRect QtWindow::bounds() const
{
    return XeRect(0, 0, width(), height());
}

void QtWindow::setBounds(const XeRect &r)
{
    resize(r.width, r.height);
}

void QtWindow::show()
{
    // On certain platforms, e.g. osx, QGLWidget::show() causes a paintGL()
    // before returning. paintGL() invokes the scheduler, which then calls
    // render on the currently active XeScreen.
    // This presents a chicken-and-egg problem in XeKernel::exec():
    // - The first screen must be loaded in order to show the window (possibly
    //   calling render on the screen)
    // - The window must be shown in order to load the first screen, or any
    //   OpenGL calls in load() will fail because there isn't an OpenGL 
    //   context yet.
    // We sidestep this issue by never invoking the scheduler in paintGL()
    // calls that are generated by QGLWidget::show().
    
    m_changingState = true;
    QGLWidget::show();
    m_changingState = false;
}

void QtWindow::hide()
{
    QGLWidget::hide();
}

bool QtWindow::isFullscreen() const
{
    return m_fullscreen;
}

void QtWindow::setFullscreen(bool f)
{
    if (f != m_fullscreen)
        toggleFullscreen();
}

void QtWindow::toggleFullscreen()
{
    m_changingState = true;
    if (m_fullscreen)
        setWindowState(windowState() & ~Qt::WindowFullScreen);
    else
        setWindowState(windowState() | Qt::WindowFullScreen);
    m_changingState = false;

    m_fullscreen = !m_fullscreen;
}

